                             __Issues__

_ Possibly add a constructor to Scrollbar widgets that takes a pointer or ....?
    some reference to the textbox, can ask it its height and its total height of
    text that the textbox widget knows how to calculate, and the current
    position in that total height, then use this information to create a
    bar with length determined by current_window_height/total_text_height, and
    centered over current_position_in_text/total_text_height, these fractions
    are multiplied by the height of the scrollbar widget since that does not
    have to be the same height as the textbox. If constructed without a textbox
    then bar is always same height of scrollbar widget, minus arrows, so
    fraction 1/1.

_ Change Object* tree to Widget* tree - low priority

_ Create a Coordinate Widget::border_offset() function to replace duplicate code

_ Create some way of decorating/specifying elements of a Textbox; scrollbars,
    scrolling with what buttons and keys, etc... template? multiple classes?

_ Easier way of specifying look of Widget and other options with some sort of
    json like syntax? Or most likely give detailed interfaces for widgets and
    documentation of those interfaces, not widget look can really be specified
    with something generic, like json.

_ Create Page_layout that can display any number of different 'screens' or pages
    of widgets. Only one page is displayed at a time and it is given the entire
    screen. instead of every page being a child, it'll only have one child and
    it will change that child out to have it printed to the screen. Also need
    some way of switching between multiple pages, maybe signals, you might have
    to make this a fixed number of pages for signal names.

_ Creating a widget object without attatching it as head or as a child or any
    other widget still prints to the screen at startup. There is no check that
    it has a parent before sending paint events to the global event queue.
    Possibly add a check that parent() != nullptr && this != head_widget().

_ Find out why upper_bound_ is sometimes larger than the length of the string,
    happens in the Textbox paint_event() function when creating the substring to
    print to the screen.

_ Add tab key to textbox, you'll have to work around the tab as change focus.
    Think of the interface, should tab to change focus just be disabled on
    Textboxes? and how to do that when Tab is removed from being sent to the
    Textbox by an event filter, maybe the event filter can check if the object
    to send to is a textbox and if so, then it sends it along instead of
    processing it.

_ Move tab focus to event filter instead of the Widget::or Object::event()
    functions.

_ Create a forms widget that has pairs of title and field, where the field is
    accessible from some variable and a signal is called whenever it is changed.
    Use partial borders or different background colors to give a nice look.

_ Make sure partial border work, test in nested widgets.

_ Create a radio button group widget, only one is selected at a time.

_ Try to work out hovering widgets, they would be on same level as the head
    widget. Their known bounds are the screen bounds. Used for Dialog Boxes and
    Pulldown menus where a widget has to be printed outside of its
    bounds/parents bounds.

_ Create Pulldown menu widget that is a hovering widget, though part of it would
    be a child to some other widget, the pull down part will be a hovering
    widget printed just under the actual menu widget.

_ Create Menu widget with selectable/highlightable options that call a signal
    enter is pressed or they are clicked. Lots of options you need to let client
    dictate in an easy way. It'd be nice to have a variable number of Menu
    options with a template or something, though for the signals to be named I'm
    not sure you could do this, you'd have to do it through some kind of
    container/index.

_ Widget placement/alignment in layouts when there is extra space that can't be
    taken by any widget, enums like left aligned, right aligned, centered,
    justified, floating...

_ Textbox with keys pressed when it has predetermined text and lower_bound will
    crash on keypresses past the length of the string.(test8) This can be fixed
    by not taking keyboard input on these types of boxes, but there are
    situations where you would still want to allow for editing of text. There is
    a bug here you should focus on instead, it probably has to do with the
    paint_event in the Meta_box widget in test8/main.cpp, the solution is a
    better interface for a static textbox, if you want a textbox that is
    editable, then you just set the contents of the textbox once at construction
    and everything should work fine from there. It is only an issue if you want
    a static textbox and keyboard input(which is redic, but its a bug and should
    be fixed with a better interface.)

_ Cursor disappears sometimes, letters still print, this might be fixed by
    compiling with optimizations? or does the event_loop calling flush()
    sometimes not put the cursor to the screen? does the cursor get coordinates
    that are not correct and therefore cannot print them on the screen?

_ Partial borders and resizing to 0 then resizing back to a typical size causes
    ncurses to not print anymore, not a crash, you've seen this before.

_ Need a better border interface that allows you more freedom to create half
    borders without text disapearing from the top and side lines

_ System head should have a built in layout if your widget does not have one, or
    at least sane widget layout with a layout, for simple widgets.

_ Allow a Widget to be able to change its default background Glyph(' ' by
    default). This is helpful when you want a line draw on a single lined text
    box(like a form, where the text input is underlined too, Glyph(' ',
    Attribute::Underlined)) and can also be helpful with checkered box
    characters for drawing and color mixtures.

_ Attributes are not cleared when new glyph with different attributes is placed
    on the same square. Look into how attributes are reset.

_ Add a Freeform layout that has Window widgets wrapping each child widget, the
    child widgets can be click and dragged to move and resize. Set TERM variable
    to xterm-1003 to get mouse move events all the time, layout keeps track of
    the currently moving/selected child widget. Overlap and click_events and
    paint_events should work fine if you re-arrange the child widgets in the
    layout so that the currently selected is at the top of the list. Though this
    would work for click events it would be painted last.. Still some things to
    work out on that one. Window widget would add a bar on top that can be
    selected and moved, propagates clicks to layout parent. bottom right corner
    icon to resize.

_ Fixed size policy in layouts currently includes border space, it should not,
    so a single box height object that wants a border should not have to resize
    its Fixed height to 3 or 2 depending on the number of borders. 

_ Consider implementing single thread animation by putting a timer around the
    ::wgetch() call on ncurses. This will make sure concurrent access to the
    ncurses library does not happen(this can happen with the current
    implementation). If the blocking call to wgetch() does not return within a
    frame time, then an AnimationFrame Event will be sent to all widgets, along
    with a call to update(). This will allow any widget to override
    animation_frame_event() function to update the state of their widget for a
    new frame. The limitation here is that you are stuck with a single frame
    rate for the entire program, unless you implement complex timer notification
    system, which adds too much complexity to the library. The whole point of
    doing this is to avoid concurrent access to the ncurses library which though
    rare, can cause crashes.

_ Animated widgets in a program make textbox widgets never have a cursor because
    the cursor is constantly being moved around to paint the animations. You'd
    have to implement your own cursor drawing to get around this, and it would
    have to be part of the animation system. 

_ Updating the background color of a widget in a paint event leaves you with the
    old background color until the next update, this is because for update you
    get a call to clear the screen, which uses the old background color, and
    then you paint new glyphs with the new background color, left with a mix of
    both, you need a call to clear screen after changing the background color.
    Actually, it should be a call to update() to post both a clear screen and
    paint event, just incase you are calling this at the end of a paint_event,
    the name set_background() implies that it is not changing the contents of
    the screen. Add a function to widget class to set the background directly
    through the widget, it'll just call down to the Brush object, but it will
    also call update(), which brush cannot do. it'll make the interface for
    setting the background a bit cleaner for the user as well. Add a function
    for foreground as well.

X Add mutex to the event_queue, lock when posting events and when processing
    events from the queue. This will help if you want to use asynchronous timers
    to perform animation by changing the state of a widget and then posting a
    paint event through a call to this->update() every certain number of timer
    ticks.


X Create a checkbox widget that has a bool state, signal when it is toggled,
    signal for when it is toggled true and for toggled false.

X Move Widget::erase_widget_screen() to Painter::clear_screen() and paint over
    borders. Is there a way to optimize this like paint_event? can paint event
    objects specify what they do? erase paint events clear the screen? or
    another type of event entirely so that you can get the post event
    optimization since most of the program time is eaten up by erasing the
    screen and these are called in place and not posted as events, this could be
    an important change. You could then call a Widget::clear_screen() function
    similar to update, that posts a clear_screen_event object to the queue, and
    the Event_queue::add_event() function could optimize out multiple clears on
    the same widget.

X Finish Scrollbar widgets

X Textbox scroll_up on backspace at top left corner.

X Add scroll_down to right arrow and scroll_up to left arrow on textbox.
    
X Textbox scroll_up() leaves the last line of text as the last line displayed
    while scrolling down. Look into Painter::move() and lower_bound_ being reset
    when scrolling up.

X If you scroll wheel all the way down on a textbox the cursor moves to the
    leftmost position and you are not about to right arrow or left arrow around.

X Add scroll_down on text input that goes below textbox widget

X Cursor up/down in Textbox should scroll text when at top and bottom.

X Very large and instant resize events(like full screen to tiny screen) can
    leave the cursor way down below and the cursor will be on the screen in
    some random position and move as you type, but all of the letters are going
    down below where you left the cursor before the resize. Handle:
    if(cursor_position > lower_bound_) then scroll down until cursor index
    is in the middle of the screen or something.

X Layout still do not take all possible space given to them because of rounding
    errors, use a similar recursive function to split up the space that should
    have been taken, but wasn't, very similar to the current recursive function
    that gives out space, but this one does not consider stretch factors, it
    just hands out one block at a time.

